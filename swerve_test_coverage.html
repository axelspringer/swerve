
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/TetsuyaXD/swerve/src/db/cache.go (0.0%)</option>
				
				<option value="file1">github.com/TetsuyaXD/swerve/src/db/db.go (0.0%)</option>
				
				<option value="file2">github.com/TetsuyaXD/swerve/src/db/domain.go (47.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "fmt"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/dynamodb"
        "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
)

// DeleteTLSCacheEntry deletes a chache entry
func (d *DynamoDB) DeleteTLSCacheEntry(key string) error <span class="cov0" title="0">{
        _, err := d.Service.DeleteItem(&amp;dynamodb.DeleteItemInput{
                TableName: aws.String(DBTablePrefix + dbCacheTableName),
                Key: map[string]*dynamodb.AttributeValue{
                        "cacheKey": {
                                S: aws.String(key),
                        },
                },
        })

        return err
}</span>

// GetTLSCache items from tls cache table
func (d *DynamoDB) GetTLSCache(key string) ([]byte, error) <span class="cov0" title="0">{
        res, err := d.Service.GetItem(&amp;dynamodb.GetItemInput{
                TableName: aws.String(DBTablePrefix + dbCacheTableName),
                Key: map[string]*dynamodb.AttributeValue{
                        "cacheKey": {
                                S: aws.String(key),
                        },
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error while getting item. %v", err)
        }</span>

        <span class="cov0" title="0">entryRes := &amp;TLSCacheEntry{}
        if err = dynamodbattribute.UnmarshalMap(res.Item, &amp;entryRes); err == nil </span><span class="cov0" title="0">{
                return []byte(entryRes.Value), nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// UpdateTLSCache updates the tls cache
func (d *DynamoDB) UpdateTLSCache(key string, data []byte) error <span class="cov0" title="0">{
        _, err := d.Service.PutItem(&amp;dynamodb.PutItemInput{
                TableName: aws.String(DBTablePrefix + dbCacheTableName),
                Item: map[string]*dynamodb.AttributeValue{
                        "cacheKey": {
                                S: aws.String(key),
                        },
                        "cacheValue": {
                                S: aws.String(string(data)),
                        },
                },
                ReturnConsumedCapacity: aws.String("TOTAL"),
        })

        return err
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 Axel Springer SE
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package db

import (
        "github.com/TetsuyaXD/swerve/src/log"
        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/dynamodb"
)

const (
        dbDomainTableName = "Domains"
        dbCacheTableName  = "DomainsTLSCache"
)

var (
        // DBTablePrefix holds the db prefix
        DBTablePrefix = ""
)

// NewDynamoDB creates a new instance
func NewDynamoDB(c *DynamoConnection, bootstrap bool) (*DynamoDB, error) <span class="cov0" title="0">{
        ddb := &amp;DynamoDB{}

        config := &amp;aws.Config{
                Region: aws.String(c.Region),
        }

        if c.Endpoint != "" </span><span class="cov0" title="0">{
                config.Endpoint = aws.String(c.Endpoint)
        }</span>

        <span class="cov0" title="0">if c.Key != "" &amp;&amp; c.Secret != "" </span><span class="cov0" title="0">{
                config.Credentials = credentials.NewStaticCredentials(c.Key, c.Secret, "")
        }</span>

        <span class="cov0" title="0">sess, err := session.NewSession(config)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ddb.Session = sess
        ddb.Service = dynamodb.New(sess)

        if bootstrap </span><span class="cov0" title="0">{
                ddb.prepareTable()
        }</span>

        <span class="cov0" title="0">return ddb, nil</span>
}

// prepareTable checks for the main table
func (d *DynamoDB) prepareTable() <span class="cov0" title="0">{
        dbDomainCacheTableCreate := &amp;dynamodb.CreateTableInput{
                TableName: aws.String(DBTablePrefix + dbCacheTableName),
                KeySchema: []*dynamodb.KeySchemaElement{
                        {AttributeName: aws.String("cacheKey"), KeyType: aws.String("HASH")},
                },
                AttributeDefinitions: []*dynamodb.AttributeDefinition{
                        {AttributeName: aws.String("cacheKey"), AttributeType: aws.String("S")},
                },
                ProvisionedThroughput: &amp;dynamodb.ProvisionedThroughput{
                        ReadCapacityUnits:  aws.Int64(1),
                        WriteCapacityUnits: aws.Int64(1),
                },
        }
        dbDomainCacheTableDescribe := &amp;dynamodb.DescribeTableInput{
                TableName: aws.String(DBTablePrefix + dbCacheTableName),
        }
        dbDomainTableCreate := &amp;dynamodb.CreateTableInput{
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
                KeySchema: []*dynamodb.KeySchemaElement{
                        {AttributeName: aws.String("domain"), KeyType: aws.String("HASH")},
                },
                AttributeDefinitions: []*dynamodb.AttributeDefinition{
                        {AttributeName: aws.String("domain"), AttributeType: aws.String("S")},
                },
                ProvisionedThroughput: &amp;dynamodb.ProvisionedThroughput{
                        ReadCapacityUnits:  aws.Int64(1),
                        WriteCapacityUnits: aws.Int64(1),
                },
        }
        dbDomainTableDescribe := &amp;dynamodb.DescribeTableInput{
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
        }

        // setup the domain table by spec
        if _, err := d.Service.DescribeTable(dbDomainTableDescribe); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                log.Info("Table 'Domains' didn't exists. Creating ...")
                if _, cerr := d.Service.CreateTable(dbDomainTableCreate); cerr != nil </span><span class="cov0" title="0">{
                        log.Fatal(cerr)
                }</span>
                <span class="cov0" title="0">log.Info("Table 'Domains' created")</span>
        }
        // setup the domain tls cache table by spec
        <span class="cov0" title="0">if _, err := d.Service.DescribeTable(dbDomainCacheTableDescribe); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                log.Info("Table 'DomainsTLSCache' didn't exists. Creating ...")
                if _, cerr := d.Service.CreateTable(dbDomainCacheTableCreate); cerr != nil </span><span class="cov0" title="0">{
                        log.Fatal(cerr)
                }</span>
                <span class="cov0" title="0">log.Info("Table 'DomainsTLSCache' created")</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2018 Axel Springer SE
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package db

import (
        "errors"
        "fmt"
        "net/url"
        "path"
        "strings"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/dynamodb"
        "github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
)

// Validate the domain
func (d *Domain) Validate() []error <span class="cov1" title="1">{
        res := []error{}

        if d.ID == "" </span><span class="cov1" title="1">{
                res = append(res, errors.New("Invalid id"))
        }</span>

        <span class="cov1" title="1">validURL, err := url.Parse("//" + d.Name)
        if d.Name == "" || err != nil || validURL.Path != "" </span><span class="cov1" title="1">{
                res = append(res, errors.New("Invalid domain name"))
        }</span>

        <span class="cov1" title="1">if d.Created == "" || d.Modified == "" </span><span class="cov1" title="1">{
                res = append(res, errors.New("Invalid domain date"))
        }</span>

        <span class="cov1" title="1">if d.Redirect == "" </span><span class="cov1" title="1">{
                res = append(res, errors.New("Invalid domain redirect target"))
        }</span>

        <span class="cov1" title="1">if d.RedirectCode &lt; 300 || d.RedirectCode &gt; 399 </span><span class="cov1" title="1">{
                res = append(res, errors.New("Invalid redirect http status code"))
        }</span>

        <span class="cov1" title="1">return res</span>
}

// GetRedirect returns calculated routes
func (d *Domain) GetRedirect(reqURL *url.URL) (string, int) <span class="cov10" title="11">{
        code := d.RedirectCode
        reURL := d.Redirect
        rePath := ""
        reQuery := ""

        if d.Promotable == true </span><span class="cov7" title="5">{
                rePath = reqURL.Path

                if len(reqURL.RawQuery) &gt; 0 </span><span class="cov6" title="4">{
                        reQuery = "?" + reqURL.RawQuery
                }</span>
        }

        <span class="cov10" title="11">if d.PathMapping != nil &amp;&amp; len(*d.PathMapping) &gt; 0 </span><span class="cov7" title="6">{
                for _, p := range *d.PathMapping </span><span class="cov7" title="6">{
                        // skip empty path mapping
                        if p.To == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // we match the path prefix
                        <span class="cov7" title="6">if strings.HasPrefix(reqURL.Path, p.From) </span><span class="cov6" title="4">{
                                rePath = reqURL.Path[len(p.From):]
                                // path redirect
                                if strings.HasPrefix(p.To, "http://") || strings.HasPrefix(p.To, "https://") </span><span class="cov3" title="2">{
                                        reURL = p.To
                                }</span> else<span class="cov3" title="2"> {
                                        if d.Promotable </span><span class="cov1" title="1">{
                                                rePath = path.Join(p.To, rePath)
                                        }</span> else<span class="cov1" title="1"> {
                                                rePath = p.To
                                        }</span>
                                }
                                <span class="cov6" title="4">break</span>
                        }
                }
        }

        <span class="cov10" title="11">if strings.HasSuffix(reURL, "/") &amp;&amp; strings.HasPrefix(rePath, "/") </span><span class="cov5" title="3">{
                rePath = strings.TrimLeft(rePath, "/")
        }</span>

        <span class="cov10" title="11">return reURL + rePath + reQuery, code</span>
}

// UpdateCertificateData updates the cert data if a domain entry exist
func (d *DynamoDB) UpdateCertificateData(domain string, data []byte) error <span class="cov0" title="0">{
        _, err := d.Service.UpdateItem(&amp;dynamodb.UpdateItemInput{
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
                Key: map[string]*dynamodb.AttributeValue{
                        "domain": {
                                S: aws.String(domain),
                        },
                },
                UpdateExpression: aws.String("set certificate = :c"),
                ReturnValues:     aws.String("UPDATED_NEW"),
                ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
                        ":c": {
                                S: aws.String(string(data)),
                        },
                },
        })

        return err
}</span>

// DeleteByID items from domains table
func (d *DynamoDB) DeleteByID(id string) (bool, error) <span class="cov0" title="0">{
        out, err := d.Service.DeleteItem(&amp;dynamodb.DeleteItemInput{
                Key: map[string]*dynamodb.AttributeValue{
                        "id": {
                                S: aws.String(id),
                        },
                },
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
        })

        return out != nil &amp;&amp; err == nil, err
}</span>

// FetchByID items from domains table
func (d *DynamoDB) FetchByID(id string) (*Domain, error) <span class="cov0" title="0">{
        res, err := d.Service.GetItem(&amp;dynamodb.GetItemInput{
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
                Key: map[string]*dynamodb.AttributeValue{
                        "id": {
                                S: aws.String(id),
                        },
                },
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error while getting item. %v", err)
        }</span>

        <span class="cov0" title="0">domainRes := &amp;Domain{}
        if err = dynamodbattribute.UnmarshalMap(res.Item, &amp;domainRes); err == nil </span><span class="cov0" title="0">{
                return domainRes, nil
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// FetchAll items from domains table
func (d *DynamoDB) FetchAll() ([]Domain, error) <span class="cov0" title="0">{
        itemList, err := d.Service.Scan(&amp;dynamodb.ScanInput{
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error while fetching domain items %v", err)
        }</span>

        <span class="cov0" title="0">recs := []Domain{}
        err = dynamodbattribute.UnmarshalListOfMaps(itemList.Items, &amp;recs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to unmarshal Dynamodb Scan Items, %v", err)
        }</span>

        <span class="cov0" title="0">return recs, nil</span>
}

// InsertDomain stores a domain
func (d *DynamoDB) InsertDomain(domain Domain) error <span class="cov0" title="0">{
        mm, err := dynamodbattribute.MarshalMap(domain)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = d.Service.PutItem(&amp;dynamodb.PutItemInput{
                Item:      mm,
                TableName: aws.String(DBTablePrefix + dbDomainTableName),
        })

        return err</span>
}

// DeleteAllDomains deletes all items from the domains table
func (d *DynamoDB) DeleteAllDomains() error <span class="cov0" title="0">{
        domains, err := d.FetchAll()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, do := range domains </span><span class="cov0" title="0">{
                _, err = d.DeleteByID(do.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Import imports a export set
func (d *DynamoDB) Import(e *ExportDomains) error <span class="cov0" title="0">{
        for _, do := range e.Domains </span><span class="cov0" title="0">{
                mm, err := dynamodbattribute.MarshalMap(do)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = d.Service.PutItem(&amp;dynamodb.PutItemInput{
                        Item:      mm,
                        TableName: aws.String(DBTablePrefix + dbDomainTableName),
                })</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
